/*
PS1 applier (concise)

- Writes ~/.config/dotfiles/shell-colors.sh exporting TrueColor ANSI variables.
- Provides Bash-bracketed and RAW variants; picks based on $BASH_VERSION at source time.
- On update, broadcasts to Kitty to source the snippet and call __cl_ps1_reload (if present), then soft-clears via `kitty @ action clear_terminal scroll active`.
- Busy shells arenâ€™t interrupted; your prompt hook should re-source on each prompt.

For full setup snippets, Home Manager notes, Kitty requirements, and tips, see notes.md in this folder.
*/

use anyhow::{anyhow, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::io::Read;
use std::process::{Command, Stdio};
#[cfg(unix)]
use std::os::unix::fs::FileTypeExt;

// Strategy for Home Manager compatibility:
// - Generate a shell snippet with exported variables (TrueColor ANSI escapes),
//   e.g. ~/.config/dotfiles/shell-colors.sh
// - Home Manager (programs.bash.initExtra) will source this on each prompt via
//   PROMPT_COMMAND. We do NOT touch rc files here.

pub fn apply(_rc_path: &str, primary_hex: &str, secondary_hex: &str) -> Result<()> {
    let colors_path = shell_colors_path()?;
    if let Some(parent) = colors_path.parent() { fs::create_dir_all(parent)?; }
    let snippet = render_color_vars(primary_hex, secondary_hex);
    let tmp = colors_path.with_extension("sh.tmp");
    fs::write(&tmp, snippet)?;
    fs::rename(&tmp, &colors_path)?;

    // Best-effort: ask all existing Kitty terminals to source theme and rebuild PS1 (soft-clear) in-place
    if let Err(e) = reload_all_kitty_shells() {
        eprintln!("[applier:ps1] warn: failed to trigger shell reloads via kitty: {e}");
    }
    Ok(())
}

fn render_color_vars(_primary_hex: &str, secondary_hex: &str) -> String {
    // Use secondary for main PS1 colors; derive a slightly darker variant for dim sections.
    let (sr, sg, sb) = hex_to_rgb(secondary_hex).unwrap_or((255, 255, 255));
    let (dr, dg, db) = darken_rgb(sr, sg, sb, 0.18);
    // Bash uses \[...\] to mark non-printing; other shells shouldn't see those.
    let sfg_bash = format!("\\[\\e[38;2;{};{};{}m\\]", sr, sg, sb); // bright accent
    let dfg_bash = format!("\\[\\e[38;2;{};{};{}m\\]", dr, dg, db); // slightly darker accent
    let sbg_bash = format!("\\[\\e[48;2;{};{};{}m\\]", sr, sg, sb);
    let dbg_bash = format!("\\[\\e[48;2;{};{};{}m\\]", dr, dg, db);
    let reset_bash = "\\[\\e[0m\\]".to_string();

    // Raw ANSI sequences using real ESC via $'...'
    let sfg_raw = format!("$'\\e[38;2;{};{};{}m'", sr, sg, sb);
    let dfg_raw = format!("$'\\e[38;2;{};{};{}m'", dr, dg, db);
    let sbg_raw = format!("$'\\e[48;2;{};{};{}m'", sr, sg, sb);
    let dbg_raw = format!("$'\\e[48;2;{};{};{}m'", dr, dg, db);
    let reset_raw = "$'\\e[0m'".to_string();
    format!(
    "# Generated by color-listener\n# secondary = {s}\n# CL_FG_PRIMARY = darker(secondary), CL_FG_SECONDARY = secondary\n# Provide both Bash-bracketed and RAW ANSI variants; pick at runtime\n# Bash-bracketed (non-printing markers)\nexport CL_FG_PRIMARY_BASH=\"{dfg_bash}\"\nexport CL_FG_SECONDARY_BASH=\"{sfg_bash}\"\nexport CL_BG_PRIMARY_BASH=\"{dbg_bash}\"\nexport CL_BG_SECONDARY_BASH=\"{sbg_bash}\"\nexport CL_RESET_BASH=\"{reset_bash}\"\n# Raw ANSI (no markers)\nexport CL_FG_PRIMARY_RAW={dfg_raw}\nexport CL_FG_SECONDARY_RAW={sfg_raw}\nexport CL_BG_PRIMARY_RAW={dbg_raw}\nexport CL_BG_SECONDARY_RAW={sbg_raw}\nexport CL_RESET_RAW={reset_raw}\n# Select appropriate set\nif [ -n \"$BASH_VERSION\" ]; then\n  export CL_FG_PRIMARY=\"$CL_FG_PRIMARY_BASH\"\n  export CL_FG_SECONDARY=\"$CL_FG_SECONDARY_BASH\"\n  export CL_BG_PRIMARY=\"$CL_BG_PRIMARY_BASH\"\n  export CL_BG_SECONDARY=\"$CL_BG_SECONDARY_BASH\"\n  export CL_RESET=\"$CL_RESET_BASH\"\nelse\n  export CL_FG_PRIMARY=$CL_FG_PRIMARY_RAW\n  export CL_FG_SECONDARY=$CL_FG_SECONDARY_RAW\n  export CL_BG_PRIMARY=$CL_BG_PRIMARY_RAW\n  export CL_BG_SECONDARY=$CL_BG_SECONDARY_RAW\n  export CL_RESET=$CL_RESET_RAW\nfi\n",
        s = secondary_hex,
        dfg_bash = dfg_bash,
        sfg_bash = sfg_bash,
        dbg_bash = dbg_bash,
        sbg_bash = sbg_bash,
        reset_bash = reset_bash,
        dfg_raw = dfg_raw,
        sfg_raw = sfg_raw,
        dbg_raw = dbg_raw,
        sbg_raw = sbg_raw,
    reset_raw = reset_raw,
    )
}

fn hex_to_rgb(hex: &str) -> Option<(u8, u8, u8)> {
    if hex.len() == 7 && hex.starts_with('#') {
        let r = u8::from_str_radix(&hex[1..3], 16).ok()?;
        let g = u8::from_str_radix(&hex[3..5], 16).ok()?;
        let b = u8::from_str_radix(&hex[5..7], 16).ok()?;
        Some((r, g, b))
    } else {
        None
    }
}

// queued re-exec removed by request; prompt hook should rebuild PS1 every time instead

fn shell_colors_path() -> Result<PathBuf> {
    let home = std::env::var("HOME").map_err(|e| anyhow!("HOME not set: {e}"))?;
    Ok(Path::new(&home).join(".config/dotfiles/shell-colors.sh"))
}

fn darken_rgb(r: u8, g: u8, b: u8, amount: f32) -> (u8, u8, u8) {
    let clamp = |v: f32| -> u8 { v.round().clamp(0.0, 255.0) as u8 };
    (
        clamp(r as f32 * (1.0 - amount)),
        clamp(g as f32 * (1.0 - amount)),
        clamp(b as f32 * (1.0 - amount)),
    )
}

// ---- Kitty helpers (local copy, minimal) ----

fn reload_all_kitty_shells() -> Result<()> {
    // Locate kitty.conf to read listen_on; prefer dotfiles kitty path used by this project
    let mut targets: Vec<String> = Vec::new();
    if let Some(base) = read_kitty_listen_on() {
        // expand per-PID variants
        if let Some(paths) = discover_unix_socket_variants(&base) {
            for p in paths { targets.push(p); }
        } else {
            targets.push(base);
        }
    }

    // Fallback: try without explicit --to (may only hit one instance)
    if targets.is_empty() {
        // Reload prompt first, then soft clear
        send_exec_to_kitty(None)?;
        let _ = soft_clear_kitty(None);
        return Ok(());
    }

    // Send to each discovered instance; ignore individual failures
    let mut any = false;
    for to in targets {
        // Reload prompt first
        if send_exec_to_kitty(Some(&to)).is_ok() { any = true; }
        // Then soft clear (non-fatal if it fails)
        let _ = soft_clear_kitty(Some(&to));
    }
    if any { Ok(()) } else { Err(anyhow!("no kitty instances accepted send-text")) }
}

fn send_exec_to_kitty(to: Option<&str>) -> Result<()> {
    // Use --stdin to ensure a trailing newline is handled correctly
    let mut cmd = Command::new("kitty");
    cmd.arg("@");
    if let Some(t) = to { cmd.args(["--to", t]); }
    cmd.args(["send-text", "--all", "--stdin"]).stdin(Stdio::piped()).stdout(Stdio::null()).stderr(Stdio::null());
    let mut child = cmd.spawn()?;
    if let Some(mut stdin) = child.stdin.take() {
        use std::io::Write as _;
        // Source color snippet and rebuild PS1 immediately (no exec). No ESC-based clears here.
        let payload = b"CL_PS1_THEME=\"$HOME/.config/dotfiles/shell-colors.sh\"; [[ -f \"$CL_PS1_THEME\" ]] && . \"$CL_PS1_THEME\"; type __cl_ps1_reload >/dev/null 2>&1 && __cl_ps1_reload\n";
        stdin.write_all(payload)?;
    }
    let status = child.wait()?;
    if status.success() { Ok(()) } else { Err(anyhow!("kitty send-text failed")) }
}

fn soft_clear_kitty(to: Option<&str>) -> Result<()> {
    use std::process::Command;
    let mut cmd = Command::new("kitty");
    cmd.arg("@");
    if let Some(t) = to { cmd.args(["--to", t]); }
    cmd.args(["action", "clear_terminal", "scroll", "active"]).stdout(Stdio::null()).stderr(Stdio::null());
    let status = cmd.status()?;
    if status.success() { Ok(()) } else { Err(anyhow!("kitty clear_terminal failed")) }
}

fn read_kitty_listen_on() -> Option<String> {
    // Try common locations; prefer repo's dotfiles path
    let mut candidates: Vec<PathBuf> = Vec::new();
    if let Ok(home) = std::env::var("HOME") {
        candidates.push(Path::new(&home).join(".config/dotfiles/kitty/kitty.conf"));
        candidates.push(Path::new(&home).join(".config/kitty/kitty.conf"));
    }
    for p in candidates {
        if p.exists() {
            let mut s = String::new();
            if fs::File::open(&p).and_then(|mut f| f.read_to_string(&mut s)).is_ok() {
                for line in s.lines() {
                    let t = line.trim();
                    if let Some(rest) = t.strip_prefix("listen_on ") {
                        let v = rest.trim();
                        if !v.is_empty() { return Some(v.to_string()); }
                    }
                }
            }
        }
    }
    None
}

// Discover all socket files that start with the base name (kitty appends -$PID)
fn discover_unix_socket_variants(target: &str) -> Option<Vec<String>> {
    let prefix = "unix:";
    if !target.starts_with(prefix) { return None; }
    let path = &target[prefix.len()..];
    if !path.starts_with('/') { return None; }
    let p = std::path::Path::new(path);
    let parent = p.parent()?;
    let fname = p.file_name()?.to_string_lossy();
    let base_prefix = fname.split_once('-').map(|(b, _)| b).unwrap_or(&fname);
    let mut out = Vec::new();
    if let Ok(read) = fs::read_dir(parent) {
        for entry in read.flatten() {
            let name = entry.file_name();
            let name = name.to_string_lossy();
            if name.starts_with(base_prefix) {
                if let Ok(ft) = entry.file_type() {
                    #[cfg(unix)]
                    {
                        if ft.is_socket() {
                            out.push(format!("unix:{}", entry.path().to_string_lossy()));
                        }
                    }
                }
            }
        }
    }
    if out.is_empty() { None } else { Some(out) }
}
